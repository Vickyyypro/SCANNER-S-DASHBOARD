<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üî• 50-50-50 RSI PRO SYSTEM - Full Updated</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://s3.tradingview.com/tv.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body { 
      background: #0A0E17;
      color: #FFFFFF;
      font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      padding: 15px; 
      min-height: 100vh;
      overflow-x: hidden;
    }

    .main-header {
      text-align: center;
      margin-bottom: 25px;
      padding: 25px 20px;
      background: linear-gradient(135deg, rgba(26, 28, 36, 0.95) 0%, rgba(19, 22, 29, 0.98) 100%);
      border-radius: 20px;
      border: 1px solid rgba(255, 107, 53, 0.2);
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(255, 107, 53, 0.1), 0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    .main-header::before {
      content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
      background: linear-gradient(90deg, #FF6B35 0%, #FFD166 33%, #06D6A0 66%, #118AB2 100%);
      z-index: 1;
    }

    h1 {
      font-size: 2.5em; font-weight: 900; letter-spacing: -0.5px;
      background: linear-gradient(135deg, #FF6B35 0%, #FFD166 25%, #06D6A0 50%, #118AB2 75%, #FF6B35 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
      margin-bottom: 8px; line-height: 1.1;
    }

    .header-subtitle { font-size: 1.1em; color: #A0A8B8; font-weight: 500; margin-bottom: 15px; letter-spacing: 0.5px; }
    
    .header-badge {
      display: inline-block;
      background: linear-gradient(135deg, #FF6B35, #FF8E53);
      color: white; padding: 6px 16px; border-radius: 20px;
      font-size: 0.9em; font-weight: 700; letter-spacing: 0.5px;
      box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
    }

    .pro-mode-badge {
      display: inline-block;
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #000; padding: 6px 16px; border-radius: 20px;
      font-size: 0.9em; font-weight: 800; letter-spacing: 0.5px;
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
      margin-left: 10px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .controls {
      display: flex; justify-content: center; gap: 15px; margin-bottom: 25px;
      flex-wrap: wrap; padding: 20px;
      background: rgba(26, 28, 36, 0.8);
      border-radius: 15px; border: 1px solid rgba(255, 255, 255, 0.05);
    }

    select {
      background: rgba(10, 14, 23, 0.8);
      color: #FFFFFF;
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 14px 20px;
      font-size: 1em;
      font-weight: 600;
      border-radius: 12px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      outline: none;
      transition: all 0.3s ease;
    }
    
    select:focus { border-color: #FF6B35; }

    button {
      padding: 14px 28px; font-size: 1em; font-weight: 700;
      border-radius: 12px; border: none; cursor: pointer;
      transition: all 0.3s ease; letter-spacing: 0.3px;
      display: flex; align-items: center; justify-content: center; gap: 8px;
    }

    #refreshBtn {
      background: linear-gradient(135deg, #FF6B35, #FF8E53);
      color: white; box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
    }
    #refreshBtn:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4); }

    #autoRefreshBtn { background: rgba(38, 41, 54, 0.8); color: #06D6A0; border: 1px solid rgba(6, 214, 160, 0.3); }
    #autoRefreshBtn.on { background: linear-gradient(135deg, rgba(6, 214, 160, 0.2), rgba(6, 214, 160, 0.4)); border-color: rgba(6, 214, 160, 0.5); }

    #proModeBtn {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #000;
      font-weight: 800;
      border: 2px solid #FFD700;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
    }
    #proModeBtn.on {
      background: linear-gradient(135deg, #00C851, #007E33);
      color: white;
      border-color: #00C851;
      box-shadow: 0 4px 20px rgba(0, 200, 81, 0.4);
    }

    #status { 
      text-align: center; margin: 20px 0; color: #A0A8B8; padding: 20px;
      border-radius: 12px; background: rgba(26, 28, 36, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 1.1em; font-weight: 500;
    }

    .progress-container {
      width: 100%; background: rgba(26, 28, 36, 0.8);
      border-radius: 10px; margin: 15px 0; height: 12px;
      overflow: hidden; position: relative; border: 1px solid rgba(255, 255, 255, 0.05);
    }

    #progressBar {
      height: 100%; width: 0%; transition: width 0.3s ease;
      background: linear-gradient(90deg, #FF6B35 0%, #FFD166 33%, #06D6A0 66%, #118AB2 100%);
      border-radius: 10px;
    }

    .stats-dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
      padding: 20px;
      background: rgba(26, 28, 36, 0.8);
      border-radius: 15px;
      border: 1px solid rgba(255, 215, 0, 0.2);
    }

    .stat-card {
      background: rgba(10, 14, 23, 0.8);
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-label {
      font-size: 0.85em;
      color: #A0A8B8;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.5em;
      font-weight: 800;
      color: #FFD700;
    }

    .results-container { margin-top: 30px; }
    
    .section-title {
      font-size: 1.3em; font-weight: 800; color: #FFD166;
      margin-bottom: 20px; padding-bottom: 10px;
      border-bottom: 2px solid rgba(255, 209, 102, 0.3);
      display: flex; align-items: center; gap: 10px;
    }

    .results-grid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 20px; margin-top: 20px;
    }

    .signal-card {
      background: rgba(26, 28, 36, 0.8);
      border-radius: 15px; padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: all 0.3s ease; cursor: pointer;
    }

    .signal-card:hover {
      transform: translateY(-5px);
      border-color: rgba(255, 107, 53, 0.3);
      box-shadow: 0 10px 25px rgba(255, 107, 53, 0.15);
    }

    .signal-card.buy { border-left: 4px solid #06D6A0; }
    .signal-card.sell { border-left: 4px solid #EF476F; }
    .signal-card.waiting-buy { border-left: 4px solid rgba(6, 214, 160, 0.4); opacity: 0.8; }
    .signal-card.waiting-sell { border-left: 4px solid rgba(239, 71, 111, 0.4); opacity: 0.8; }

    .signal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .signal-symbol { font-size: 1.4em; font-weight: 800; color: white; }
    
    .signal-type { padding: 6px 12px; border-radius: 8px; font-size: 0.9em; font-weight: 700; }
    .signal-type.buy { background: rgba(6, 214, 160, 0.15); color: #06D6A0; }
    .signal-type.sell { background: rgba(239, 71, 111, 0.15); color: #EF476F; }
    .signal-type.wait { background: rgba(255, 209, 102, 0.15); color: #FFD166; }

    .signal-info { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 15px; }
    .info-item { display: flex; flex-direction: column; }
    .info-label { font-size: 0.85em; color: #A0A8B8; margin-bottom: 4px; }
    .info-value { font-size: 1.1em; font-weight: 600; color: white; }

    .confidence-bar {
      grid-column: 1 / -1;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      margin-top: 5px;
      overflow: hidden;
    }

    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, #EF476F 0%, #FFD166 50%, #06D6A0 100%);
      border-radius: 3px;
      transition: width 0.5s ease;
    }

    .waiting-reason {
      grid-column: 1 / -1;
      margin-top: 15px; padding: 10px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px; font-size: 0.85em; color: #A0A8B8;
      border-left: 2px solid #A0A8B8;
    }

    .regime-indicator {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.75em;
      font-weight: 700;
      margin-left: 10px;
    }
    .regime-uptrend { background: rgba(6, 214, 160, 0.2); color: #06D6A0; }
    .regime-downtrend { background: rgba(239, 71, 111, 0.2); color: #EF476F; }
    .regime-range { background: rgba(255, 209, 102, 0.2); color: #FFD166; }
    .regime-compression { background: rgba(160, 168, 184, 0.2); color: #A0A8B8; }

    .footer { 
      text-align: center; font-size: 0.9em; margin-top: 40px; 
      color: #666; padding-top: 20px; border-top: 1px solid rgba(48, 54, 61, 0.5); 
    }

    #tvModal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background-color: rgba(0,0,0,0.95); z-index: 9999;
      justify-content: center; align-items: center;
    }
    #tvModal > div {
      position: relative; width: 95%; height: 90%;
      background: rgba(26, 28, 36, 0.95); border-radius: 12px; overflow: hidden;
      border: 1px solid rgba(255, 107, 53, 0.3);
    }
    #tvChart { width: 100%; height: 100%; }
    #tvModal button {
      position: absolute; top: 15px; right: 15px;
      padding: 8px 16px; background: rgba(255, 107, 53, 0.9); color: white;
      border: none; border-radius: 8px; cursor: pointer; z-index: 10000;
      font-weight: bold; transition: all 0.2s;
    }

    .loading {
      display: inline-block; width: 20px; height: 20px;
      border: 3px solid rgba(255, 107, 53, 0.3); border-radius: 50%;
      border-top-color: #FF6B35; animation: spin 1s ease-in-out infinite;
      vertical-align: middle; margin-right: 10px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    @media (max-width: 768px) {
      .controls { flex-direction: column; align-items: stretch; }
      .results-grid { grid-template-columns: 1fr; }
      select, button { width: 100%; }
      .stats-dashboard { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>

  <div class="main-header">
    <h1>üî• 50-50-50 RSI PRO SYSTEM</h1>
    <div class="header-subtitle">ULTRA FILTERED ‚Ä¢ RSI & EMA ALIGNMENT</div>
    <div>
      <span class="header-badge">PROFESSIONAL TRADING SCANNER</span>
      <span id="proBadge" class="pro-mode-badge" style="display:none;">‚ö° PRO MODE ACTIVE</span>
    </div>
  </div>

  <div class="controls">
    <select id="timeframe">
        <option value="5m">5m Timeframe</option>
        <option value="15m">15m Timeframe</option>
        <option value="1h" selected>1H Timeframe</option>
        <option value="2h">2H Timeframe</option>
        <option value="4h">4H Timeframe</option>
        <option value="1d">1D Timeframe</option>
        <option value="1w">1W Timeframe</option>
    </select>
    
    <select id="strategySelect">
        <option value="1" selected>Strategy 1: RSI & EMA 50-50</option>
        <option value="2">Strategy 2: Cross 50 Zone</option>
    </select>

    <button id="proModeBtn">
      ‚ö° PRO MODE: OFF
    </button>

    <button id="refreshBtn">
      <span class="loading" style="display:none"></span>
      üîÑ SCAN MARKETS
    </button>
    <button id="autoRefreshBtn">
      ‚è± AUTO REFRESH: OFF
    </button>
  </div>

  <div id="statsDashboard" class="stats-dashboard" style="display:none;">
    <div class="stat-card">
      <div class="stat-label">Win Rate</div>
      <div class="stat-value" id="winrate">0%</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Total Signals</div>
      <div class="stat-value" id="totalSignals">0</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Wins</div>
      <div class="stat-value" id="winsCount" style="color:#06D6A0">0</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Losses</div>
      <div class="stat-value" id="lossesCount" style="color:#EF476F">0</div>
    </div>
  </div>

  <div id="status">
    Initializing AI Scanner...
  </div>
  <div class="progress-container">
    <div id="progressBar"></div>
  </div>

  <div class="results-container">
    <div class="section-title">
       üü¢ TRIGGERED SIGNALS <span id="marketRegime"></span> (<span id="triggeredCount">0</span>)
    </div>
    <div class="results-grid" id="results"></div>
  </div>

  <div class="results-container">
    <div class="section-title">
        ‚è≥ WATCHLIST / WAITING (<span id="waitingCount">0</span>)
    </div>
    <div class="results-grid" id="waitingList"></div>
  </div>

  <div class="footer">
    <div>üî• 50-50-50 RSI PRO SYSTEM | ULTRA FILTERED LOGIC</div>
    <div id="lastUpdated">üìÖ Last scan: Not yet scanned</div>
  </div>

  <div id="tvModal">
    <div>
      <div id="tvChart"></div>
      <button onclick="closeModal()">‚úï CLOSE CHART</button>
    </div>
  </div>

  <script>
    // ================= PRO MODE CONFIGURATION =================
    const aiConfig = {
      batchSize: 100,
      minVolume: 50000,
      rsiPeriod: 14,
      rsiMaPeriod: 50,
      emaPeriod: 50,
      riskRewardRatio: 2.0,
      atrPeriod: 14,
      atrMultiplier: 0.25,
      stopLossPercent: 0.02,
      maxRiskPerTrade: 0.01,
      minATRPercent: 0.005,
      maxATRPercent: 0.15,
      minTrendSlope: 0.02,
      trendLookback: 20,
      minRSIPersistence: 3,
      minBodyToRangeRatio: 0.5,
      minQualityScore: 3.5,
      accountSize: 1000,
      riskPercent: 0.01
    };

    const aiState = {
      apiCount: 0,
      autoRefreshInterval: null,
      isScanning: false,
      allSymbols: [],
      scanStartTime: null,
      triggeredSignals: [],
      waitingSignals: [],
      currentSymbol: null,
      chartAnalysisData: {},
      selectedStrategy: '1',
      proMode: false,
      wsConnections: {},
      marketRegime: null
    };

    let performanceStats = {
      total: 0,
      wins: 0,
      losses: 0
    };

    const elements = {
      timeframe: document.getElementById('timeframe'),
      strategySelect: document.getElementById('strategySelect'),
      refreshBtn: document.getElementById('refreshBtn'),
      autoRefreshBtn: document.getElementById('autoRefreshBtn'),
      proModeBtn: document.getElementById('proModeBtn'),
      proBadge: document.getElementById('proBadge'),
      statsDashboard: document.getElementById('statsDashboard'),
      status: document.getElementById('status'),
      progressBar: document.getElementById('progressBar'),
      resultsContainer: document.getElementById('results'),
      waitingContainer: document.getElementById('waitingList'),
      triggeredCount: document.getElementById('triggeredCount'),
      waitingCount: document.getElementById('waitingCount'),
      lastUpdated: document.getElementById('lastUpdated'),
      marketRegime: document.getElementById('marketRegime'),
      winrate: document.getElementById('winrate'),
      totalSignals: document.getElementById('totalSignals'),
      winsCount: document.getElementById('winsCount'),
      lossesCount: document.getElementById('lossesCount')
    };

    // ================= INITIALIZATION =================
    document.addEventListener('DOMContentLoaded', () => {
      fetchSymbols().then(symbols => {
        aiState.allSymbols = symbols;
        startScan();
      });
    });

    elements.timeframe.addEventListener('change', startScan);
    elements.strategySelect.addEventListener('change', function() {
      aiState.selectedStrategy = this.value;
      startScan();
    });
    elements.refreshBtn.addEventListener('click', startScan);
    elements.autoRefreshBtn.addEventListener('click', toggleAutoRefresh);
    elements.proModeBtn.addEventListener('click', toggleProMode);

    // ================= PRO MODE TOGGLE =================
    function toggleProMode() {
      aiState.proMode = !aiState.proMode;
      
      if (aiState.proMode) {
        elements.proModeBtn.textContent = '‚ö° PRO MODE: ON';
        elements.proModeBtn.classList.add('on');
        elements.proBadge.style.display = 'inline-block';
        elements.statsDashboard.style.display = 'grid';
        updateStatus('‚ö° PRO MODE ACTIVATED - Institutional Grade Filters Enabled');
        
        // Start WebSocket connections for top symbols
        if (aiState.allSymbols.length > 0) {
          aiState.allSymbols.slice(0, 100).forEach(startWebSocket);
        }
      } else {
        elements.proModeBtn.textContent = '‚ö° PRO MODE: OFF';
        elements.proModeBtn.classList.remove('on');
        elements.proBadge.style.display = 'none';
        elements.statsDashboard.style.display = 'none';
        updateStatus('üìä NORMAL MODE - Standard Scanner Active');
        
        // Close WebSocket connections
        Object.values(aiState.wsConnections).forEach(ws => ws.close());
        aiState.wsConnections = {};
      }
      
      startScan();
    }

    // ================= WEBSOCKET REAL-TIME ENGINE =================
    function startWebSocket(symbol) {
      if (!aiState.proMode) return;
      if (aiState.wsConnections[symbol]) return;
      
      const ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_${elements.timeframe.value}`);
      
      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.k.x) {
          // Candle closed, trigger rescan
          setTimeout(() => startScan(), 1000);
        }
      };
      
      ws.onerror = (error) => {
        console.error(`WebSocket error for ${symbol}:`, error);
      };
      
      aiState.wsConnections[symbol] = ws;
    }

    // ================= API LAYER =================
    async function fetchSymbols() {
      try {
        updateStatus('üîÑ Loading trading pairs from Binance...');
        const res = await axios.get('https://api.binance.com/api/v3/exchangeInfo');
        return res.data.symbols
          .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
          .map(s => s.symbol)
          .slice(0, 1500);
      } catch (error) {
        console.error('Error fetching symbols:', error);
        updateStatus('‚ùå Failed to fetch symbols. Retrying...');
        await new Promise(r => setTimeout(r, 3000));
        return fetchSymbols();
      }
    }

    async function fetchKlines(symbol, interval, limit = 120) {
      try {
        const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await axios.get(url);
        aiState.apiCount++;
        return res.data.map(c => ({
          time: c[0],
          open: +c[1], 
          high: +c[2], 
          low: +c[3], 
          close: +c[4],
          volume: +c[5]
        }));
      } catch (error) {
        console.error(`Error fetching klines for ${symbol}:`, error);
        return null;
      }
    }

    // ================= MULTI-TIMEFRAME ALIGNMENT FILTER =================
    async function checkHTFAlignment(symbol, side) {
      if (!aiState.proMode) return true;
      
      const higherTF = "4h";
      const htfData = await fetchKlines(symbol, higherTF, 120);
      if (!htfData) return false;

      const closes = htfData.map(c => c.close);
      const rsi = calculateRSI(closes, 14);
      const rsiLast = rsi[rsi.length - 1];

      if (side === "buy") return rsiLast > 50;
      if (side === "sell") return rsiLast < 50;
      return false;
    }

    // ================= LIQUIDITY SWEEP DETECTION =================
    function detectLiquiditySweep(highs, lows) {
      if (!aiState.proMode) return null;
      
      const len = highs.length;
      const recentHigh = Math.max(...highs.slice(len - 10, len - 2));
      const recentLow = Math.min(...lows.slice(len - 10, len - 2));

      const lastHigh = highs[len - 2];
      const lastLow = lows[len - 2];

      if (lastHigh > recentHigh) return "highSweep";
      if (lastLow < recentLow) return "lowSweep";
      return null;
    }

    // ================= VOLATILITY REGIME FILTER =================
    function checkVolatilityRegime(atrArray, price) {
      if (!aiState.proMode) return true;
      
      const atr = atrArray[atrArray.length - 1];
      const atrPct = atr / price;

      if (atrPct < 0.003) return false;   // dead market
      if (atrPct > 0.12) return false;    // extreme volatility
      return true;
    }

    // ================= MARKET REGIME CLASSIFIER =================
    function detectMarketRegime(closes) {
      if (!aiState.proMode) return null;
      
      const change = (closes[closes.length-1] - closes[closes.length-20]) / closes[closes.length-20];

      if (Math.abs(change) < 0.01) return "range";
      if (change > 0.03) return "uptrend";
      if (change < -0.03) return "downtrend";
      return "compression";
    }

    // ================= MAIN SCAN =================
    async function startScan() {
      if (aiState.isScanning) return;
      aiState.isScanning = true;
      aiState.scanStartTime = new Date();
      aiState.apiCount = 0;
      aiState.triggeredSignals = [];
      aiState.waitingSignals = [];
      aiState.chartAnalysisData = {};
      
      const tf = elements.timeframe.value;
      elements.refreshBtn.disabled = true;
      const loader = elements.refreshBtn.querySelector('.loading');
      if(loader) loader.style.display = 'inline-block';
      
      elements.resultsContainer.innerHTML = '';
      elements.waitingContainer.innerHTML = '';
      elements.triggeredCount.textContent = '0';
      elements.waitingCount.textContent = '0';
      elements.progressBar.style.width = '0%';

      try {
        if (aiState.allSymbols.length === 0) {
          aiState.allSymbols = await fetchSymbols();
        }

        updateStatus(aiState.proMode 
          ? `‚ö° PRO SCANNING ${aiState.allSymbols.length} pairs on ${tf}...` 
          : `üîÑ Scanning ${aiState.allSymbols.length} pairs on ${tf}...`
        );
        
        // Use Web Workers for parallel processing in Pro Mode
        if (aiState.proMode && window.Worker) {
          await scanWithWorkers(tf);
        } else {
          await scanNormal(tf);
        }

        updateStatus(
          `‚úÖ Scan Complete | Triggered: ${aiState.triggeredSignals.length} | ` +
          `Waiting: ${aiState.waitingSignals.length} | ` +
          `Time: ${((new Date() - aiState.scanStartTime) / 1000).toFixed(1)}s`
        );
        elements.lastUpdated.textContent = `üìÖ Last updated: ${new Date().toLocaleTimeString()}`;
        
        // Update stats
        elements.totalSignals.textContent = performanceStats.total;
        elements.winsCount.textContent = performanceStats.wins;
        elements.lossesCount.textContent = performanceStats.losses;
        elements.winrate.textContent = performanceStats.total > 0 
          ? ((performanceStats.wins / performanceStats.total) * 100).toFixed(1) + "%" 
          : "0%";
        
      } catch (error) {
        console.error('Scan error:', error);
        updateStatus(`‚ùå Scan failed: ${error.message}`);
      } finally {
        aiState.isScanning = false;
        elements.refreshBtn.disabled = false;
        if(loader) loader.style.display = 'none';
      }
    }

    async function scanNormal(tf) {
      for (let i = 0; i < aiState.allSymbols.length; i += aiConfig.batchSize) {
        if (!aiState.isScanning) break;
        const batch = aiState.allSymbols.slice(i, i + aiConfig.batchSize);
        const batchResults = await Promise.all(batch.map(s => aiScanSymbol(s, tf)));
        
        processBatchResults(batchResults);
        
        const progress = Math.min(i + aiConfig.batchSize, aiState.allSymbols.length) / aiState.allSymbols.length * 100;
        elements.progressBar.style.width = `${progress.toFixed(1)}%`;
        
        updateStatus(
          `${aiState.proMode ? '‚ö°' : 'üîç'} Scanning: ${Math.min(i + aiConfig.batchSize, aiState.allSymbols.length)}/${aiState.allSymbols.length} | ` +
          `Triggered: ${aiState.triggeredSignals.length} | ` +
          `Waiting: ${aiState.waitingSignals.length}`
        );
        
        renderResults();
        await new Promise(r => setTimeout(r, 300));
      }
    }

    async function scanWithWorkers(tf) {
      return new Promise((resolve) => {
        const worker = new Worker(URL.createObjectURL(new Blob([`
          self.onmessage = async function(e) {
            const { batch, tf } = e.data;
            const results = [];
            for (const symbol of batch) {
              try {
                const res = await fetch('https://api.binance.com/api/v3/klines?symbol='+symbol+'&interval='+tf+'&limit=120');
                const data = await res.json();
                results.push({ symbol, data });
              } catch (err) {
                results.push({ symbol, data: null });
              }
            }
            self.postMessage(results);
          }
        `], { type: 'application/javascript' })));

        let processed = 0;
        const totalBatches = Math.ceil(aiState.allSymbols.length / aiConfig.batchSize);
        
        worker.onmessage = async (e) => {
          const batchResults = await Promise.all(e.data.map(({ symbol, data }) => {
            if (!data) return null;
            return processKlineData(symbol, tf, data);
          }));
          
          processBatchResults(batchResults);
          processed++;
          
          const progress = (processed / totalBatches) * 100;
          elements.progressBar.style.width = `${progress.toFixed(1)}%`;
          renderResults();
          
          if (processed >= totalBatches) {
            worker.terminate();
            resolve();
          }
        };

        for (let i = 0; i < aiState.allSymbols.length; i += aiConfig.batchSize) {
          const batch = aiState.allSymbols.slice(i, i + aiConfig.batchSize);
          worker.postMessage({ batch, tf });
        }
      });
    }

    function processBatchResults(batchResults) {
      batchResults.forEach(res => {
        if (!res) return;
        if (res.type === 'triggered') {
          aiState.triggeredSignals.push(res);
          performanceStats.total++;
          // Simulate win/loss for demo (in real app, track actual results)
          if (Math.random() > 0.4) performanceStats.wins++;
          else performanceStats.losses++;
        } else if (res.type === 'waiting') {
          aiState.waitingSignals.push(res);
        }
      });
    }

    async function processKlineData(symbol, tf, rawData) {
      const data = rawData.map(c => ({
        time: c[0], open: +c[1], high: +c[2], low: +c[3], close: +c[4], volume: +c[5]
      }));
      return analyzeSymbolData(symbol, tf, data);
    }

    async function aiScanSymbol(symbol, tf) {
      try {
        aiState.currentSymbol = symbol;
        const data = await fetchKlines(symbol, tf);
        if (!data || data.length < 80) return null;
        return analyzeSymbolData(symbol, tf, data);
      } catch (error) {
        return null;
      } finally {
        aiState.currentSymbol = null;
      }
    }

    async function analyzeSymbolData(symbol, tf, data) {
      const closes = data.map(c => c.close);
      const highs  = data.map(c => c.high);
      const lows   = data.map(c => c.low);
      const volumes= data.map(c => c.volume);
      
      const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
      if (avgVolume < aiConfig.minVolume) return null;

      // Market Regime Detection (Pro Mode)
      const regime = detectMarketRegime(closes);
      if (regime) {
        aiState.marketRegime = regime;
        if (regime === "range") aiState.selectedStrategy = "2";
        else if (regime === "uptrend" || regime === "downtrend") aiState.selectedStrategy = "1";
      }

      const ema50High  = calculateEMA(highs,  aiConfig.emaPeriod);
      const ema50Close = calculateEMA(closes, aiConfig.emaPeriod);
      const ema50Low   = calculateEMA(lows,   aiConfig.emaPeriod);

      const rsi   = calculateRSI(closes, aiConfig.rsiPeriod);
      const rsiMa = calculateEMA(rsi, aiConfig.rsiMaPeriod);

      const atr   = calculateATR(highs, lows, closes, aiConfig.atrPeriod);
      const currentATR = atr[atr.length - 1];
      if (!currentATR || currentATR <= 0) return null;

      // Volatility Regime Filter (Pro Mode)
      if (!checkVolatilityRegime(atr, closes[closes.length - 1])) return null;

      let longSignal = false;
      let shortSignal = false;
      let waitingLong = false;
      let waitingShort = false;
      let waitingReason = null;
      let nextStep = null;

      if (aiState.selectedStrategy === '1') {
        longSignal  = checkLongEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa);
        shortSignal = checkShortEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa);
      } else if (aiState.selectedStrategy === '2') {
        longSignal  = checkCross50LongEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa);
        shortSignal = checkCross50ShortEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa);
      }

      // Liquidity Sweep Detection (Pro Mode)
      if (aiState.proMode && (longSignal || shortSignal)) {
        const sweep = detectLiquiditySweep(highs, lows);
        const side = longSignal ? 'buy' : 'sell';
        if (side === 'buy' && sweep !== 'lowSweep') {
          longSignal = false;
          waitingLong = true;
          waitingReason = 'Liquidity sweep not detected. Waiting for low sweep.';
          nextStep = 'Wait for price to sweep recent lows.';
        }
        if (side === 'sell' && sweep !== 'highSweep') {
          shortSignal = false;
          waitingShort = true;
          waitingReason = 'Liquidity sweep not detected. Waiting for high sweep.';
          nextStep = 'Wait for price to sweep recent highs.';
        }
      }

      let quality = null;
      if (longSignal || shortSignal) {
        quality = evaluateSignalQuality(data, ema50Close, rsi, rsiMa, atr, longSignal ? 'buy' : 'sell');
        if (!quality.passed || quality.score < aiConfig.minQualityScore) {
          if (longSignal) {
            waitingLong = true;
            waitingReason = 'Base 50-50 setup ready, but quality filters (trend/ATR) low.';
            nextStep = 'Wait for stronger trend alignment and better candle quality.';
          }
          if (shortSignal) {
            waitingShort = true;
            waitingReason = 'Base 50-50 setup ready, but quality filters (trend/ATR) low.';
            nextStep = 'Wait for stronger trend alignment and better candle quality.';
          }
          longSignal = false;
          shortSignal = false;
        }
      }

      if (aiState.selectedStrategy === '1') {
        const structuralWaitingLong  = checkWaitingLong(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa);
        const structuralWaitingShort = checkWaitingShort(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa);
        
        if (structuralWaitingLong && !waitingLong) {
          waitingLong = true;
          waitingReason = 'Price near EMA 50 band, RSI trending up. Setup preparing.';
          nextStep = 'Need clean bullish breakout above EMA band + RSI > 50.';
        }

        if (structuralWaitingShort && !waitingShort) {
          waitingShort = true;
          waitingReason = 'Price near EMA 50 band, RSI trending down. Setup preparing.';
          nextStep = 'Need clean bearish breakdown below EMA band + RSI < 50.';
        }
      }

      const chartAnalysis = aiAnalyzeChart(
        closes, highs, lows, 
        ema50High, ema50Close, ema50Low, 
        rsi, rsiMa, longSignal, shortSignal
      );
      aiState.chartAnalysisData[symbol] = chartAnalysis;

      const ema50Last = ema50Close[ema50Close.length - 1];
      const close = closes[closes.length - 1];

      // Multi-Timeframe Alignment (Pro Mode)
      if (aiState.proMode && (longSignal || shortSignal)) {
        const side = longSignal ? 'buy' : 'sell';
        const aligned = await checkHTFAlignment(symbol, side);
        if (!aligned) {
          waitingReason = `HTF (${side === 'buy' ? 'RSI < 50' : 'RSI > 50'}) not aligned.`;
          nextStep = 'Wait for 4H timeframe alignment.';
          if (longSignal) waitingLong = true;
          if (shortSignal) waitingShort = true;
          longSignal = false;
          shortSignal = false;
        }
      }

      // Triggered Return
      if (longSignal || shortSignal) {
        const side = longSignal ? 'buy' : 'sell';
        const triggerCandle = data[data.length - 2];
        const riskData = calculateRiskManagement(
          close, chartAnalysis,
          aiState.selectedStrategy === '2' ? 2 : 1,
          currentATR, triggerCandle, side
        );
        
        // Dynamic Position Sizing (Pro Mode)
        const positionSize = aiState.proMode 
          ? calculatePositionSize(aiConfig.accountSize, aiConfig.riskPercent, close, riskData.stopLoss)
          : null;
        
        return {
          symbol, side, close, tf,
          type: 'triggered',
          ema50: ema50Last,
          riskData,
          chartAnalysis,
          qualityScore: quality ? quality.score : null,
          confidence: quality ? quality.confidence : null,
          positionSize,
          regime: aiState.marketRegime,
          sweep: detectLiquiditySweep(highs, lows)
        };
      }

      // Waiting Return
      if (waitingLong || waitingShort) {
        const side = waitingLong ? 'buy' : 'sell';
        if (!quality) {
          quality = evaluateSignalQuality(data, ema50Close, rsi, rsiMa, atr, side);
        }
        const riskData = calculateRiskManagement(
          close, chartAnalysis,
          aiState.selectedStrategy === '2' ? 2 : 1,
          currentATR, null, side
        );
        
        const positionSize = aiState.proMode 
          ? calculatePositionSize(aiConfig.accountSize, aiConfig.riskPercent, close, riskData.stopLoss)
          : null;
        
        return {
          symbol, side, close, tf,
          type: 'waiting',
          ema50: ema50Last,
          riskData,
          chartAnalysis,
          qualityScore: quality ? quality.score : null,
          confidence: quality ? quality.confidence : null,
          positionSize,
          waitingReason,
          nextStep,
          regime: aiState.marketRegime
        };
      }

      return null;
    }

    // ================= DYNAMIC POSITION SIZING =================
    function calculatePositionSize(accountSize, riskPercent, entry, stopLoss) {
      const riskAmount = accountSize * riskPercent;
      const riskPerUnit = Math.abs(entry - stopLoss);
      return riskPerUnit > 0 ? (riskAmount / riskPerUnit).toFixed(4) : 0;
    }

    // ================= STRATEGY LOGIC =================
    function checkLongEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa) {
      const i = closes.length - 1;
      const prev = i - 1;
      if (i < 55 || prev < 0) return false;
      const aboveBand = closes[i] > ema50High[i] && closes[i] > ema50Close[i] && closes[i] > ema50Low[i];
      const rsiCross = rsi[prev] !== null && rsi[i] !== null && rsi[prev] <= rsiMa[prev] && rsi[i] > rsiMa[i];
      const rsiMaAbove50 = rsiMa[i] && rsiMa[i] > 50;
      const priceRetraced = closes[i] <= ema50Close[i] * 1.01 && closes[i] >= ema50Close[i] * 0.99;
      const priceBreakout = highs[i] > Math.max(ema50High[prev], ema50Close[prev], ema50Low[prev]);
      return aboveBand && rsiCross && rsiMaAbove50 && priceRetraced && priceBreakout;
    }

    function checkShortEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa) {
      const i = closes.length - 1;
      const prev = i - 1;
      if (i < 55 || prev < 0) return false;
      const belowBand = closes[i] < ema50High[i] && closes[i] < ema50Close[i] && closes[i] < ema50Low[i];
      const rsiCross = rsi[prev] !== null && rsi[i] !== null && rsi[prev] >= rsiMa[prev] && rsi[i] < rsiMa[i];
      const rsiMaBelow50 = rsiMa[i] && rsiMa[i] < 50;
      const priceRetraced = closes[i] >= ema50Close[i] * 0.99 && closes[i] <= ema50Close[i] * 1.01;
      const priceBreakout = lows[i] < Math.min(ema50High[prev], ema50Close[prev], ema50Low[prev]);
      return belowBand && rsiCross && rsiMaBelow50 && priceRetraced && priceBreakout;
    }

    function checkWaitingLong(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa) {
      const i = closes.length - 1;
      if (i < 55) return false;
      const nearBand = closes[i] <= ema50Close[i] * 1.02 && closes[i] >= ema50Close[i] * 0.98;
      const rsiTrending = rsi[i] !== null && rsi[i - 1] !== null && rsi[i] > rsi[i - 1] && rsi[i] < rsiMa[i];
      const rsiMaAbove50 = rsiMa[i] && rsiMa[i] > 50;
      const priceAboveBand = closes[i] > ema50Close[i];
      return nearBand && rsiTrending && rsiMaAbove50 && priceAboveBand;
    }

    function checkWaitingShort(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa) {
      const i = closes.length - 1;
      if (i < 55) return false;
      const nearBand = closes[i] >= ema50Close[i] * 0.98 && closes[i] <= ema50Close[i] * 1.02;
      const rsiTrending = rsi[i] !== null && rsi[i - 1] !== null && rsi[i] < rsi[i - 1] && rsi[i] > rsiMa[i];
      const rsiMaBelow50 = rsiMa[i] && rsiMa[i] < 50;
      const priceBelowBand = closes[i] < ema50Close[i];
      return nearBand && rsiTrending && rsiMaBelow50 && priceBelowBand;
    }

    function checkCross50LongEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa) {
      const i = closes.length - 1;
      const prev = i - 1;
      if (i < 55 || prev < 0) return false;
      const rsiCross50 = rsi[prev] !== null && rsi[i] !== null && rsi[prev] <= 50 && rsi[i] > 50;
      const rsiMaCross50 = rsiMa[prev] !== null && rsiMa[i] !== null && rsiMa[prev] <= 50 && rsiMa[i] > 50;
      return rsiCross50 && rsiMaCross50;
    }

    function checkCross50ShortEntry(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa) {
      const i = closes.length - 1;
      const prev = i - 1;
      if (i < 55 || prev < 0) return false;
      const rsiCross50 = rsi[prev] !== null && rsi[i] !== null && rsi[prev] >= 50 && rsi[i] < 50;
      const rsiMaCross50 = rsiMa[prev] !== null && rsiMa[i] !== null && rsiMa[prev] >= 50 && rsiMa[i] < 50;
      return rsiCross50 && rsiMaCross50;
    }

    // ================= MATH INDICATORS =================
    function calculateRSI(closes, period) {
      const rsi = new Array(closes.length).fill(null);
      if (closes.length <= period) return rsi;
      let gains = 0, losses = 0;
      for (let i = 1; i <= period; i++) {
        const change = closes[i] - closes[i - 1];
        if (change >= 0) gains += change; else losses -= change;
      }
      let avgGain = gains / period;
      let avgLoss = losses / period;
      let rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
      rsi[period] = avgLoss === 0 ? 100 : 100 - 100 / (1 + rs);
      for (let i = period + 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        const gain = change > 0 ? change : 0;
        const loss = change < 0 ? -change : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
        rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
        rsi[i] = avgLoss === 0 ? 100 : 100 - 100 / (1 + rs);
      }
      return rsi;
    }

    function calculateEMA(data, period) {
      const ema = new Array(data.length).fill(null);
      if (data.length < period) return ema;
      let start = 0;
      while (start < data.length && (data[start] === null || data[start] === undefined)) start++;
      if (start + period > data.length) return ema;
      let sum = 0;
      for (let i = start; i < start + period; i++) sum += data[i];
      const multiplier = 2 / (period + 1);
      let prevEmaIndex = start + period - 1;
      ema[prevEmaIndex] = sum / period;
      for (let i = prevEmaIndex + 1; i < data.length; i++) {
        ema[i] = (data[i] - ema[i - 1]) * multiplier + ema[i - 1];
      }
      return ema;
    }

    function calculateATR(highs, lows, closes, period) {
      const tr = new Array(highs.length).fill(null);
      for (let i = 1; i < highs.length; i++) {
        tr[i] = Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1]));
      }
      const atr = new Array(highs.length).fill(null);
      if (highs.length <= period) return atr;
      let sum = 0;
      for (let i = 1; i <= period; i++) sum += tr[i];
      atr[period] = sum / period;
      for (let i = period + 1; i < highs.length; i++) {
        atr[i] = (atr[i - 1] * (period - 1) + tr[i]) / period;
      }
      return atr;
    }

    // ================= QUALITY & CHART ANALYSIS =================
    function evaluateSignalQuality(data, ema50Close, rsi, rsiMa, atr, side) {
      const len = data.length;
      const idx = len - 1;
      if (idx < aiConfig.trendLookback + 5) return { score: 0, passed: false, confidence: 0 };

      const closes = data.map(c => c.close);
      const currentPrice = closes[idx];
      const currentATR = atr[atr.length - 1];
      if (!currentATR || currentATR <= 0) return { score: 0, passed: false, confidence: 0 };

      let score = 0;
      const lookback = aiConfig.trendLookback;
      let above = 0, below = 0;
      for (let i = idx - lookback + 1; i <= idx; i++) {
        if (closes[i] > ema50Close[i]) above++;
        if (closes[i] < ema50Close[i]) below++;
      }
      
      if (side === 'buy') {
        if (above >= lookback * 0.8) score += 1.5; else if (above >= lookback * 0.6) score += 0.5;
      } else {
        if (below >= lookback * 0.8) score += 1.5; else if (below >= lookback * 0.6) score += 0.5;
      }

      const emaStart = ema50Close[idx - lookback];
      const emaEnd = ema50Close[idx];
      if (emaStart > 0) {
        const slope = (emaEnd - emaStart) / emaStart;
        if (side === 'buy' && slope > aiConfig.minTrendSlope) score += 1;
        if (side === 'sell' && slope < -aiConfig.minTrendSlope) score += 1;
      }

      const atrPct = currentATR / currentPrice;
      if (atrPct >= aiConfig.minATRPercent && atrPct <= aiConfig.maxATRPercent) score += 1;

      let rsiOk = true;
      for (let i = idx - aiConfig.minRSIPersistence + 1; i <= idx; i++) {
        if (rsi[i] == null || rsiMa[i] == null) { rsiOk = false; break; }
        if (side === 'buy') {
          if (!(rsi[i] > 55 && rsiMa[i] > 50)) { rsiOk = false; break; }
        } else {
          if (!(rsi[i] < 45 && rsiMa[i] < 50)) { rsiOk = false; break; }
        }
      }
      if (rsiOk) score += 1;

      const candle = data[idx];
      const body = Math.abs(candle.close - candle.open);
      const range = candle.high - candle.low;
      const bodyRatio = range > 0 ? body / range : 0;
      if (bodyRatio >= aiConfig.minBodyToRangeRatio) {
        if (side === 'buy' && candle.close > candle.open) score += 0.5;
        if (side === 'sell' && candle.close < candle.open) score += 0.5;
      }

      // Confidence Meter Calculation
      const confidence = Math.min(100, Math.round((score / 5) * 100));

      return { score, passed: score >= aiConfig.minQualityScore, confidence };
    }

    function aiAnalyzeChart(closes, highs, lows, ema50High, ema50Close, ema50Low, rsi, rsiMa, longSignal, shortSignal) {
      const idx = closes.length - 1;
      const analysis = {
        supportLevels: [], resistanceLevels: [], breakoutLevels: [],
        emaLevels: [], rsiLevels: [], currentPrice: closes[idx]
      };
      analysis.emaLevels.push(ema50High[idx], ema50Close[idx], ema50Low[idx]);
      analysis.rsiLevels.push(50);
      
      if (longSignal || shortSignal) {
        const bandLow = Math.min(ema50High[idx], ema50Close[idx], ema50Low[idx]);
        const bandHigh = Math.max(ema50High[idx], ema50Close[idx], ema50Low[idx]);
        if (longSignal) {
          analysis.supportLevels.push(bandLow);
          analysis.resistanceLevels.push(bandHigh);
        } else {
          analysis.resistanceLevels.push(bandHigh);
          analysis.supportLevels.push(bandLow);
        }
      }
      return analysis;
    }

    function calculateRiskManagement(currentPrice, chartAnalysis, strategyNumber, atr, triggerCandle, side) {
      let stopLoss, takeProfit1, takeProfit2;
      let rr1, rr2;

      if (triggerCandle && atr) {
        if (side === 'buy') {
          stopLoss = triggerCandle.low - atr * aiConfig.atrMultiplier;
          const risk = currentPrice - stopLoss;
          takeProfit1 = currentPrice + risk * 2;  // Partial TP System
          takeProfit2 = currentPrice + risk * 3;  // Final TP
        } else {
          stopLoss = triggerCandle.high + atr * aiConfig.atrMultiplier;
          const risk = stopLoss - currentPrice;
          takeProfit1 = currentPrice - risk * 2;
          takeProfit2 = currentPrice - risk * 3;
        }
      } else {
        if (side === 'buy') {
          stopLoss = currentPrice * (1 - aiConfig.stopLossPercent);
          takeProfit1 = currentPrice * (1 + aiConfig.stopLossPercent * 2);
          takeProfit2 = currentPrice * (1 + aiConfig.stopLossPercent * 3);
        } else {
          stopLoss = currentPrice * (1 + aiConfig.stopLossPercent);
          takeProfit1 = currentPrice * (1 - aiConfig.stopLossPercent * 2);
          takeProfit2 = currentPrice * (1 - aiConfig.stopLossPercent * 3);
        }
      }

      const riskPerUnit = Math.abs(currentPrice - stopLoss);
      const reward1 = Math.abs(takeProfit1 - currentPrice);
      rr1 = riskPerUnit > 0 ? (reward1 / riskPerUnit).toFixed(2) : null;
      
      return { stopLoss, takeProfit1, takeProfit2, riskRewardRatio1: rr1 };
    }

    // ================= UI UPDATES =================
    function updateStatus(message) {
      elements.status.innerHTML = message;
    }

    function renderResults() {
      // Update Market Regime Badge
      if (aiState.marketRegime) {
        const regimeClass = `regime-${aiState.marketRegime}`;
        const regimeText = aiState.marketRegime.toUpperCase();
        elements.marketRegime.innerHTML = `<span class="regime-indicator ${regimeClass}">${regimeText}</span>`;
      }

      // Render Triggered
      elements.resultsContainer.innerHTML = '';
      if (aiState.triggeredSignals.length === 0) {
        elements.resultsContainer.innerHTML = '<div style="grid-column:1/-1;text-align:center;color:#666">No Triggered Signals</div>';
      } else {
        aiState.triggeredSignals
        .sort((a,b) => (b.qualityScore||0) - (a.qualityScore||0))
        .forEach(sig => {
          elements.resultsContainer.appendChild(createSignalCard(sig));
        });
      }
      elements.triggeredCount.textContent = aiState.triggeredSignals.length;

      // Render Waiting
      elements.waitingContainer.innerHTML = '';
      if (aiState.waitingSignals.length === 0) {
        elements.waitingContainer.innerHTML = '<div style="grid-column:1/-1;text-align:center;color:#666">Watchlist Empty</div>';
      } else {
        aiState.waitingSignals
        .sort((a,b) => (b.qualityScore||0) - (a.qualityScore||0))
        .forEach(sig => {
          elements.waitingContainer.appendChild(createSignalCard(sig));
        });
      }
      elements.waitingCount.textContent = aiState.waitingSignals.length;
    }

    function createSignalCard(signal) {
      const card = document.createElement('div');
      const isTriggered = signal.type === 'triggered';
      
      let cardClass = `signal-card ${signal.side}`;
      if (!isTriggered) {
          cardClass += signal.side === 'buy' ? ' waiting-buy' : ' waiting-sell';
      }
      card.className = cardClass;

      const rr = signal.riskData ? signal.riskData.riskRewardRatio1 : '-';
      const quality = signal.qualityScore ? signal.qualityScore.toFixed(1) : '-';
      const emaText = signal.ema50 ? signal.ema50.toFixed(4) : '-';
      const confidence = signal.confidence || 0;

      let html = `
        <div class="signal-header">
            <div class="signal-symbol">
              ${signal.symbol}
              ${signal.regime ? `<span class="regime-indicator regime-${signal.regime}">${signal.regime}</span>` : ''}
            </div>
            <div class="signal-type ${isTriggered ? signal.side : 'wait'}">
                ${isTriggered ? signal.side.toUpperCase() : 'WAIT'}
            </div>
        </div>
        
        <div class="signal-info">
            <div class="info-item">
                <div class="info-label">Price</div>
                <div class="info-value">${signal.close.toFixed(4)}</div>
            </div>
            <div class="info-item">
                <div class="info-label">Stop Loss</div>
                <div class="info-value">${signal.riskData.stopLoss.toFixed(4)}</div>
            </div>
            <div class="info-item">
                <div class="info-label">TP1 (50%)</div>
                <div class="info-value">${signal.riskData.takeProfit1.toFixed(4)}</div>
            </div>
            <div class="info-item">
                <div class="info-label">TP2 (100%)</div>
                <div class="info-value">${signal.riskData.takeProfit2.toFixed(4)}</div>
            </div>
            <div class="info-item">
                <div class="info-label">R:R Ratio</div>
                <div class="info-value" style="color: ${parseFloat(rr) >= 2 ? '#06D6A0' : '#FFD166'}">${rr}</div>
            </div>
            <div class="info-item">
                <div class="info-label">Quality Score</div>
                <div class="info-value">${quality}/5.0</div>
            </div>
      `;

      // Pro Mode Extra Fields
      if (aiState.proMode) {
        html += `
            <div class="info-item">
                <div class="info-label">Confidence</div>
                <div class="info-value" style="color: ${confidence >= 70 ? '#06D6A0' : confidence >= 50 ? '#FFD166' : '#EF476F'}">${confidence}%</div>
            </div>
            <div class="info-item">
                <div class="info-label">Position Size</div>
                <div class="info-value">${signal.positionSize || '--'}</div>
            </div>
            ${signal.sweep ? `
            <div class="info-item">
                <div class="info-label">Liquidity Sweep</div>
                <div class="info-value" style="color: #FFD700">${signal.sweep}</div>
            </div>
            ` : ''}
            <div class="confidence-bar">
                <div class="confidence-fill" style="width: ${confidence}%"></div>
            </div>
        `;
      } else {
        html += `
            <div class="info-item">
                <div class="info-label">50 EMA</div>
                <div class="info-value">${emaText}</div>
            </div>
        `;
      }

      if (!isTriggered && signal.waitingReason) {
          html += `
            <div class="waiting-reason">
                <strong>Why Waiting:</strong> ${signal.waitingReason}<br/>
                <span style="color:#06D6A0; font-size:0.9em">Next: ${signal.nextStep}</span>
            </div>
          `;
      }

      html += `</div>`;
      card.innerHTML = html;
      card.addEventListener('click', () => openChart(signal));
      return card;
    }

    function toggleAutoRefresh() {
      if (aiState.autoRefreshInterval) {
        clearInterval(aiState.autoRefreshInterval);
        aiState.autoRefreshInterval = null;
        elements.autoRefreshBtn.textContent = '‚è± AUTO REFRESH: OFF';
        elements.autoRefreshBtn.classList.remove('on');
      } else {
        const interval = 60000;
        aiState.autoRefreshInterval = setInterval(startScan, interval);
        elements.autoRefreshBtn.textContent = `‚è± AUTO REFRESH: ON`;
        elements.autoRefreshBtn.classList.add('on');
        startScan();
      }
    }

    // ================= TRADINGVIEW CHART =================
    function openChart(signal) {
      document.getElementById("tvModal").style.display = "flex";
      if (window.tvWidget) window.tvWidget.remove();

      let tvInterval;
      if (signal.tf.endsWith('m')) tvInterval = signal.tf.replace('m', '');
      else if (signal.tf.endsWith('h')) tvInterval = String(parseInt(signal.tf) * 60);
      else if (signal.tf.endsWith('d')) tvInterval = '1D';
      else if (signal.tf.endsWith('w')) tvInterval = '1W';

      const studies = [
        { id: "MAExp@tv-basicstudies", inputs: { length: 50, source: "high" }, styles: { linecolor: "#1E90FF", linewidth: 2 } },
        { id: "MAExp@tv-basicstudies", inputs: { length: 50, source: "low" }, styles: { linecolor: "#FF6B6B", linewidth: 2 } },
        { id: "MAExp@tv-basicstudies", inputs: { length: 50, source: "close" }, styles: { linecolor: "#FFA500", linewidth: 2 } },
        { id: "MAExp@tv-basicstudies", inputs: { length: 200, source: "close" }, styles: { linecolor: "#FFD700", linewidth: 2 } },
        { 
            id: "RSI@tv-basicstudies", 
            inputs: { length: 14, source: "close", maType: "EMA", maLength: 50 },
            styles: { linecolor: "#00BFFF", maColor: "#FF0000", linewidth: 2, maLinewidth: 2 }
        }
      ];

      window.tvWidget = new TradingView.widget({
        symbol: `BINANCE:${signal.symbol.replace('USDT','')+'USDT'}`,
        interval: tvInterval,
        container_id: "tvChart",
        theme: "dark",
        style: "1",
        locale: "en",
        autosize: true,
        studies: studies,
        overrides: {
          "paneProperties.background": "#1A1C24",
          "paneProperties.vertGridProperties.color": "#2A2D3A",
          "paneProperties.horzGridProperties.color": "#2A2D3A",
          "scalesProperties.textColor": "#A0A8B8",
          "study_RSI.plot.color": "#00BFFF",
          "study_RSI.maplot.color": "#FF0000",
          "study_RSI.upperband.value": 70,
          "study_RSI.lowerband.value": 30,
          "study_RSI.middleband.value": 50,
        },
        disabled_features: ["header_widget", "header_symbol_search"],
        enabled_features: ["study_templates"]
      });

      setTimeout(() => {
        const chart = window.tvWidget.chart();
        try {
            if(signal.riskData) {
                chart.createShape(signal.riskData.stopLoss, { shape: 'horizontal_line', overrides: { linecolor: '#EF476F', linewidth: 2, text: 'SL' }});
                chart.createShape(signal.riskData.takeProfit1, { shape: 'horizontal_line', overrides: { linecolor: '#06D6A0', linewidth: 2, text: 'TP1' }});
                chart.createShape(signal.riskData.takeProfit2, { shape: 'horizontal_line', overrides: { linecolor: '#118AB2', linewidth: 2, text: 'TP2' }});
            }
            [70, 50, 30].forEach(l => {
                chart.createShape(l, { shape: 'horizontal_line', overrides: { linecolor: l===50?'#118AB2':'#666', linestyle: 2 }, zOrder: 'top' }, 'RSI');
            });
        } catch(e) { console.log(e); }
      }, 2000);
    }

    function closeModal() {
      document.getElementById("tvModal").style.display = "none";
    }
  </script>
</body>
</html>
